# 問題

SQLite3のDB接続インスタンスを使い回しているとエラーになる。

https://tonton7.blogspot.jp/2011/05/python-sqlite.html

```
ProgrammingError: SQLite objects created in a thread can only be used in that same thread.The object was created in thread id {id_1} and this is thread id {id_2}
```

SQLite3はマルチスレッドで安全に動作させられない。これは仕様っぽい。コンパイルフラグでエラーを出さないよう解除できるっぽいが、それで安全なアクセスができるわけじゃないっぽい。その点は諦めるしかない。

ただ、マルチスレッドを使ったつもりはないのに、DB接続インスタンスを使い回しているとエラーになる。使用後は`close()`すべきなのだろうが面倒。いっそ、`connect()`, `begin(), `commit()`のフレームワークを作りたいと思った。

# 要件

```python
with dataset.connect(DB_URL) as DB: # transact()用引数と区別できない！
    db.begin()
    res = func(DB, *args, **kwargs) # dbとfunc引数を区別できない！
    db.commit()
    return res
```

変数|説明|要件
----|----|----
`DB_URL`|DB接続文字列|呼出側で任意の値を渡したい
`DB`|DBインスタンス|func側で参照することで任意の操作をしたい
`func`|メソッド|任意クラスの任意メソッド。任意の引数と戻り値

DB定義側
```python
class MyDb:
    def CreateTable_MyTable(db):
        db.query('create table MyDb (...);')
    def Update_MyTable(db, name_values):
        db.query('update into MyDb (name_values.keys()) values (name_values.values());')
```

呼出側
```python
MyDb().DB_URL = 'sqlite:////tmp/test.db'
MyDb().CreateTable_MyTable()
MyDb().CreateTable_MyTable({'Name': 'Bob'})
```

* DB定義側は第一引数`db`で`dataset.connect()`を参照したいが、呼出側では不要にしたい
* `db`以外は任意の引数を使いたい

#  解法

* デコレータ(@connect, @transact)
    * `@connect('sqlite:////tmp/test.db')`のように関数定義でDBファイルパスのハードコーディングが必要
        * 動的に変更できない
        * パスをクラス変数に持たせても動的に変更できない
        * metaclassで変数をもたせると`@connect(DB_URL)`となるが`DB_URL`が未定義エラーとなる
* クラス
    * 呼出側で固有メソッド名で呼び出し、固有変数のみ渡したい
        * 固有メソッド定義側の第一引数は`db`(dataset.connect())である
            * `TransactionSetter.py`
                * `res = self.__transaction(db, *args, **kwargs)`
        * `./src/5/TransactionSetter.py`
            * 固有メソッド定義クラスを渡して、DBアクセス用クラスを作って返す
                * 呼出側はアクセサを使うことで目的達成できる
    * `TransactionSetter`によるアクセサ作成を自動化したい
        * `./src/6/db/AccesserMeta.py`

結局、新しいアクセス用クラスを動的生成することで解決した。

## デコレータでは解決できない

```python
def connect(func):
    import functools
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        print('args:', args)
        print('kwargs:', kwargs)
        with dataset.connect(args[0]) as db: # transact()用引数と区別できない！
            return transact(*args, **kwargs) # 呼び出せない！
    return wrapper
    
def transact(func):
    import functools
    @functools.wraps(func)
    def wrapper(*args,**kwargs):
        db.begin()
        res = func(db, *args, **kwargs) # dbとfunc引数を区別できない！
        db.commit()
        return res
    return wrapper
```

ほかにも色々やったがダメだった。

関数定義するとき`@connect`と書くが、.pyファイルが読み込まれた時点で実行されるっぽい。そのせいで、動的に変数を渡せない。`DB_URL`とか渡せない。

